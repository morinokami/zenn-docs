---
title: "クライアントサイドレンダリング"
---

---

> アプリケーションの UI をクライアント上でレンダリングする

---

![](/images/learning-patterns/client-side-rendering-1280w.jpg)

:::message
原文は[こちら](https://www.patterns.dev/posts/client-side-rendering/)
:::

## クライアントサイドレンダリング

クライアントサイドレンダリング (Client-Side Rendering、CSR) において、サーバーがレンダリングするのは、ページの骨格となる HTML コンテナのみです。ページ上にコンテンツを表示するために必要なロジック、データの取得、テンプレート化、ルーティングは、ブラウザあるいはクライアント上で実行される JavaScript コードによって処理されます。CSR は、シングルページアプリケーション (single-page application) を構築するための手法として普及し、Web サイトをインストール方式のアプリケーションに近づけることに貢献しました。

他のパターンの利点をよりよく理解するためにも、まずはクライアントサイドレンダリングについて深く考察し、それがどのような場面で上手く機能するのか、またどのような欠点をもつのかについて確認していきましょう。

## CSR の基本構造

React を使用してページ上に現在時刻を表示し、それを[更新する](https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element)簡単な例を見てみます。

HTML:

```html
<div id="root"></div>
```

JS:

```jsx
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
 ReactDOM.render(element,document.getElementById('root'));
}
setInterval(tick, 1000);
```

HTML は、1 つのルート div タグだけで構成されています。コンテンツの表示と更新に関しては、すべてもう一方の JavaScript によって処理されます。サーバーへのラウンドトリップはなく、レンダリングされた HTML はその場で更新されます。時刻の代わりに、為替レートや株価など、API から取得したリアルタイムの情報を、ページのリロードやサーバーとのラウンドトリップなしで表示することなども可能です。

## JavaScript のバンドルとパフォーマンス

画像やデータストアから得たデータの表示、イベント処理などのためにページの複雑さが増すにつれて、ページのレンダリングに必要な JavaScript コードの複雑さとサイズも大きくなっていきます。大きな JavaScript バンドルによる CSR は、ページの FCP と TTI を増加させます。

![](/images/learning-patterns/client-side-rendering-1.png)

画像の出典: https://www.youtube.com/watch?v=k-A2VfuUROg&feature=youtu.be

上の図からわかるように、bundle.js のサイズが大きくなると、FCP と TTI は右方向に押し出されます。これは、FP から FCP までの間ずっと、ユーザーが真っ白な画面を見続けることを意味します。

## クライアントサイド React の長所と短所

React では、アプリケーションロジックのほとんどはクライアント上で実行され、データの取得や保存のために API コールを通じてサーバーとやり取りをおこないます。つまり、ほぼすべての UI がクライアント上で生成されるということになります。Web アプリケーション全体は、最初のリクエストで読み込まれます。ユーザーがリンクをクリックしてページ遷移しても、ページをレンダリングするためのサーバーへのリクエストは発生しません。ビューやデータを変更するためのコードは、クライアント上で実行されるのです。

CSR により、ページを更新せずにナビゲーションをおこなうシングルページアプリケーションが可能となり、優れたユーザーエクスペリエンスを提供できるようになりました。ビューを変更するために処理されるデータはそれほど多くはないため、ページ間のルーティングは一般に速く、CSR アプリケーションの応答性を高く見せることができます。また、CSR により、開発者はクライアントとサーバーのコードを明確に分離することができます。

このように素晴らしいインタラクティブな体験を提供する CSR ですが、いくつかの落とし穴もあります。

1. **SEO に対する考慮**: 多くのウェブクローラーは、サーバーでレンダリングされたウェブサイトをそのまま解釈することができます。ところが、クライアントサイドレンダリングでは、事態は少し複雑になります。ペイロードは大きく、大量のネットワークリクエスト (たとえば API レスポンス) も発生するため、クローラーがインデックスを終えるまでに、意味のあるコンテンツをレンダリングできないことがあるためです。クローラーは JavaScript を解釈できるかもしれませんが、それも限界があります。そのため、クライアント上でレンダリングされるウェブサイトを SEO フレンドリーにするためには、なんらかの措置が必要となるのです。
2. **パフォーマンス**: クライアントサイドレンダリングでは、サーバーへのラウンドトリップがないため、ユーザーの操作に対する応答時間が大幅に改善されます。ただし、ブラウザが最初にクライアントサイドでコンテンツをレンダリングする際には、まず JavaScript をロードして処理が開始されるのを待つ必要があります。そのため、ユーザーは最初のページが読み込まれるまでに多少のタイムラグを感じることになります。これは、JS バンドルのサイズが大きくなったり、クライアントの処理能力が十分でない場合、ユーザーエクスペリエンスに影響を与える可能性があります。
3. **コードの保守性**: コードの一部が、異なる言語で動くクライアントとサーバー (API) 間で重複してしまう可能性があります。また、ビジネスロジックをきれいに分離することができない場合もあります。たとえば、通貨や日付のフィールドに対する、バリデーションやフォーマット処理などです。
4. **データの取得**: クライアントサイドレンダリングでは、データ取得は通常イベント駆動型となります。ページが最初に読み込まれるときには何のデータもないこともあります。そしてその後、ページロードやボタンクリックなどのイベントが発生すると、API  呼び出しによってデータが取得されるという流れです。取得するデータのサイズによっては、アプリケーションのロード時間やユーザーの操作に対する応答時間が増加する可能性があります。

これらの考慮事項がもつ重要性は、個々のアプリケーションごとに異なるでしょう。開発者は多くの場合、応答速度を犠牲にせずに素早くページを提供できるような、SEO フレンドリーなソリューションを探し求めます。しかし、さまざまなパフォーマンス基準に割り当てられる優先順位は、アプリケーションの要件によって異なるはずです。まったく別のパターンを採用せずとも、クライアントサイドレンダリングに若干の調整を加えるだけで十分な場合もあるでしょう。

## CSR のパフォーマンス改善

CSR のパフォーマンスは JavaScript バンドルのサイズに反比例するため、パフォーマンスを最適化するために JavaScript コードを設計することが最も重要です。以下のリストがその一助となるかもしれません。

<!-- TODO: do it -->
* **JavaScript のサイズを切り詰める**: 最初のページロードのために、適度に厳しく JavaScript のサイズを切り詰めるようにしましょう。最初にロードされるバンドルを、ミニファイと gzip 圧縮により 100-170KB 以下にできれば悪くありません。Code can then be loaded on-demand as features are needed.
* **プリロード**: このテクニックは、ページのライフサイクルの早い段階で、ページが必要とする重要なリソースを先行して読み込む (preload) ために使用します。重要なリソースに JavaScript を含めることもでき、HTML の `<head>` セクションに以下のディレクティブを指定することでプリロードすることができます。
  ```html
  <link rel="preload" as="script" href="critical.js">
  ```
  これにより、ページレンダリングが始まる前に、`critical.js` ファイルの読み込みを開始するようブラウザに通知することができます。その結果、スクリプトはより早い段階で利用可能となり、ページレンダリングの流れがブロックされなくなるため、パフォーマンスが改善されることとなります。
* **遅延読み込み**: 遅延読み込み (lazy loading) を使用すると、画面の初期表示に必須でないリソースを見極めた上で、必要になってからそれらをロードすることができます。この方法により、最初にロードされるリソースのサイズが小さくなるため、ページの初期ロード時間が改善される可能性があります。たとえば、チャット用のウィジェットコンポーネントは、一般にページロード直後には必要とされないため、遅延読み込みすることができるでしょう。
* **コード分割**: JavaScript コードのバンドルが大きくなりすぎないよう、バンドルを分割することができます。コード分割 (code-splitting) は、[Webpack](https://webpack.js.org/guides/code-splitting/) のようなバンドラーでサポートされており、実行時に動的にロード可能な複数のバンドルを作成することができます。また、コード分割は、JavaScript リソースの遅延読み込みも可能にします。
* **サービスワーカーによるアプリケーションシェルのキャッシュ**: このテクニックは、ユーザーインターフェイスを動かすために必要な最小限の HTML、CSS、JavaScript である、アプリケーションシェル (application shell) をキャッシュするというものです。サービスワーカー (service worker) は、アプリケーションシェルをオフラインでキャッシュするために使用することができます。その他のコンテンツを必要に応じて徐々にロードしていく、ネイティブのシングルページアプリケーションのような使い心地を提供するために役立ちます。

これらのテクニックを用いれば、CSR により、適切な FCP および TTI のもとで、高速なシングルページアプリケーションの体験を提供することができるはずです。続いては、サーバーサイドレンダリングにより、スペクトラムの反対側で何ができるかについて見ていきましょう。
