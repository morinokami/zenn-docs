---
title: "サーバーサイドレンダリング"
---

---

> ユーザーのリクエストに応じて、レンダリングする HTML をサーバー上で生成する

---

![](/images/learning-patterns/server-side-rendering-1280w.jpg)

:::message
原文は[こちら](https://www.patterns.dev/posts/server-side-rendering/)
:::

## サーバーサイドレンダリング

サーバーサイドレンダリング (SSR) は、Web コンテンツのレンダリング手法として最も歴史のあるものの一つです。SSR では、ユーザーのリクエストに応じて、レンダリングするページコンテンツの完全な HTML を生成します。コンテンツには、データストアや外部 API から取得したデータが含まれることもあります。

<!-- TODO: mov どうする？ -->
[動画による説明](https://res.cloudinary.com/ddxwdqwkr/video/upload/v1617495417/patterns.dev/serverside-rendering-1.mov)

データソースへの接続とそこからのデータ取得は、サーバー上で処理されます。コンテンツを整えるために必要なHTMLもサーバーで生成されます。よって、SSR を使えば、データの取得とテンプレート化のための追加的なラウンドトリップを回避することができます。そのため、レンダリングをおこなうコードはクライアントには不要であり、これに対応する JavaScript をクライアントに送るも必要はありません。

SSR では、すべてのリクエストは別々に扱われ、サーバーにおいて新しいリクエストとして処理されます。連続する 2 つのリクエストの出力がほぼ同じだとしても、サーバーはそれを一から処理・生成します。サーバーはユーザー間で共有されるため、その処理能力も、ある時点でアクティブなすべてのユーザー間で共有されます。

## 古典的な SSR の実装

古典的な SSR と JavaScript を使った、現在時刻を表示するページの作り方について見てみましょう。

```html:index.html
<!DOCTYPE html>
<html>
   <head>
       <title>Time</title>
   </head>
   <body>
       <div>
       <h1>Hello, world!</h1>
       <b>It is <div id=currentTime></div></b>
       </div>
   </body>
</html>
```

```js:index.js
function tick() {
    var d = new Date();
    var n = d.toLocaleTimeString();
    document.getElementById("currentTime").innerHTML = n;
}
setInterval(tick, 1000);
```

同じ出力となる CSR のコードとの違いに注目してください。また、この HTML はサーバーによってレンダリングされますが、表示される時刻は JavaScript の関数 `tick()` によって計算される、クライアントのローカルタイムであることに注意してください。サーバーの時刻などのサーバー固有のデータを表示したい場合は、それをレンダリング前に HTML に埋め込む必要があります。つまり、サーバーへのラウンドトリップなしで自動的に更新されることはありません。

---

## SSR - 利点と欠点

レンダリング用のコードをサーバー上で実行し、JavaScript を削減することには、以下のようなメリットがあります。

### JavaScript を減らすと、FCP や TTI の高速化につながる

<!-- TODO: FCP = TTI は言い過ぎでは -->
ページ上に複数の UI 要素やアプリケーションロジックがある場合、SSR は CSR に比べ、JavaScript のサイズがかなり少なくなります。そのため、スクリプトの読み込みや処理に必要な時間が短くなります。**FP**、**FCP**、**TTI** は短くなり、**FCP** ＝ **TTI** となります。SSR を使えば、すべての画面要素が表示されてインタラクティブになるまでユーザーが待たされることはなくなります。

![](/images/learning-patterns/server-side-rendering-1.png)

画像の出典: https://developers.google.com/web/updates/2019/02/rendering-on-the-web

### クライアントサイド JavaScript のサイズに余裕が生まれる

開発チームは、望ましいパフォーマンスを達成するために、ページ上の JS の量を制限することが求められます。SSR では、ページのレンダリングに必要な JS が取り除かれるため、アプリケーションに必要なサードパーティの JS のためのスペースを確保することができます。

### SEO 対策

検索エンジンのクローラーは、SSR アプリケーションのコンテンツを問題なくクロールできるため、ページの SEO を確実におこなうことができます。

上記のような利点から、SSR は静的コンテンツに最適です。しかし、いくつかの欠点もあり、すべてのシナリオにおいて完璧というわけではありません。

### 遅い TTFB

すべての処理がサーバー上でおこなわれるため、以下のような場合、サーバーからのレスポンスが遅れる可能性があります。

* 複数のユーザーからの同時アクセスにより、サーバーに過剰な負荷がかかっている
* ネットワークが遅い
* サーバーのコードが最適化されていない

### 特定の操作においてページ全体の再読み込みが必要となる

クライアント上ですべてのコードが実行されるわけではないため、各操作においてサーバーとのラウンドトリップが何度も必要となり、ページの再読み込みが発生します。このため、ユーザーは操作の合間に長い時間待つ必要があり、
